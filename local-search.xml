<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SocketFront</title>
    <link href="/2024/09/30/SocketFront/"/>
    <url>/2024/09/30/SocketFront/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SocketServer</title>
    <link href="/2024/09/30/SocketServer/"/>
    <url>/2024/09/30/SocketServer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>timeRequiredToBuy</title>
    <link href="/2024/09/30/timeRequiredToBuy/"/>
    <url>/2024/09/30/timeRequiredToBuy/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p><p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到 <strong>队尾</strong> 重新排队（<strong>瞬间</strong> 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p><p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>tickets &#x3D; [2,3,2], k &#x3D; 2</p><p><strong>输出：</strong>6</p><p><strong>解释：</strong></p><ul><li>队伍一开始为 [2,3,2]，第 k 个人以下划线标识。</li><li>在最前面的人买完票后，队伍在第 1 秒变成 [3,2,1]。</li><li>继续这个过程，队伍在第 2 秒变为[2,1,2]。</li><li>继续这个过程，队伍在第 3 秒变为[1,2,1]。</li><li>继续这个过程，队伍在第 4 秒变为[2,1]。</li><li>继续这个过程，队伍在第 5 秒变为[1,1]。</li><li>继续这个过程，队伍在第 6 秒变为[1]。第 k 个人完成买票，所以返回 6。</li></ul><p><strong>示例 2：</strong></p><p><strong>输入：</strong>tickets &#x3D; [5,1,1,1], k &#x3D; 0</p><p><strong>输出：</strong>8</p><p><strong>解释：</strong></p><ul><li>队伍一开始为 [5,1,1,1]，第 k 个人以下划线标识。</li><li>在最前面的人买完票后，队伍在第 1 秒变成 [1,1,1,4]。</li><li>继续这个过程 3 秒，队伍在第 4 秒变为[4]。</li><li>继续这个过程 4 秒，队伍在第 8 秒变为[]。第 k 个人完成买票，所以返回 8。</li></ul><p><strong>提示：</strong></p><ul><li><code>n == tickets.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= tickets[i] &lt;= 100</code></li><li><code>0 &lt;= k &lt; n</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p> 利用循环队列<code>i++ % n</code>的思维，重复买票过程记录时间</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> timeRequiredToBuy(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; tickets, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> n = tickets.size();<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tickets[k] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tickets[i] != <span class="hljs-number">0</span>)&#123;<br>                tickets[i]--;<br>                <span class="hljs-keyword">count</span>++;<br>            &#125;<br>            i++;<br>            i = i % n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>模拟</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>isPalindrome</title>
    <link href="/2024/09/27/isPalindrome/"/>
    <url>/2024/09/27/isPalindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数</p><p>是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">输入：<span class="hljs-variable language_">x</span> = <span class="hljs-number">121</span><br>输出：<span class="hljs-symbol">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">输入：<span class="hljs-variable language_">x</span> = <span class="hljs-number">-121</span><br>输出：<span class="hljs-symbol">false</span><br>解释：从左向右读, 为 <span class="hljs-number">-121</span> 。 从右向左读, 为 <span class="hljs-number">121</span>- 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">输入：<span class="hljs-variable language_">x</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-symbol">false</span><br>解释：从右向左读, 为 <span class="hljs-number">01</span> 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPalindrome(<span class="hljs-built_in">int</span> x) &#123;<br>        <span class="hljs-built_in">string</span> s = std::to_string(x);<br>        <span class="hljs-built_in">int</span> n = s.length();<br><br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组元素和与数字和的绝对差</title>
    <link href="/2024/09/26/differenceOfSum/"/>
    <url>/2024/09/26/differenceOfSum/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个正整数数组 <code>nums</code> 。</p><ul><li><strong>元素和</strong> 是 <code>nums</code> 中的所有元素相加求和。</li><li><strong>数字和</strong> 是 <code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。</li></ul><p>返回 <strong>元素和</strong> 与 <strong>数字和</strong> 的绝对差。</p><p><strong>注意：</strong>两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,15,6,3]<br>输出：9<br>解释：<br>nums 的元素和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 25 </span>。<br>nums 的数字和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 16 </span>。<br>元素和与数字和的绝对差是 |25 - 16| =<span class="hljs-number"> 9 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,4]<br>输出：0<br>解释：<br>nums 的元素和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 10 </span>。<br>nums 的数字和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 10 </span>。<br>元素和与数字和的绝对差是 |10 - 10| =<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2000</code></li><li><code>1 &lt;= nums[i] &lt;= 2000</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>数学问题，元素之和必然大于数字之和，对于<code>nums[i]</code>，只需逐位求出每位数字相加即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-built_in">int</span> differenceOfSum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.size();<br>        <span class="hljs-built_in">int</span> sum_1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> sum_2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = nums[i];<br>            sum_1 += <span class="hljs-built_in">num</span>;<br>            <span class="hljs-keyword">do</span>&#123;<br>                sum_2 += <span class="hljs-built_in">num</span>%<span class="hljs-number">10</span>;<br>                <span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span>/<span class="hljs-number">10</span>;<br>            &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">num</span>&gt;=<span class="hljs-number">10</span>);<br>            sum_2 += <span class="hljs-built_in">num</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum_1 - sum_2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lengthOfLongestSubstring</title>
    <link href="/2024/09/25/lengthOfLongestSubstring/"/>
    <url>/2024/09/25/lengthOfLongestSubstring/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123; <br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">//定义</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            <span class="hljs-keyword">auto</span> it = umap.<span class="hljs-built_in">find</span>(s[i]);<br>            <span class="hljs-keyword">if</span>(it == <span class="hljs-number">0</span>)&#123;<br>                umap.<span class="hljs-built_in">insert</span>(Map::<span class="hljs-built_in">value_type</span>(s[i], i));<br>                i++;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cout&lt;&lt;it-&gt;second&lt;&lt;endl;<br>                i = it-&gt;second + <span class="hljs-number">1</span>;<br>            &#125;<br>            mx = <span class="hljs-built_in">max</span>(mx,count);<br>                <br>        &#125;<br>        <span class="hljs-keyword">return</span> mx;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>边积分最高的节点</title>
    <link href="/2024/09/25/edgeScore/"/>
    <url>/2024/09/25/edgeScore/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个有向图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> ，其中每个节点都 <strong>恰有一条</strong> 出边。</p><p>图由一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 <strong>有向</strong> 边。</p><p>节点 <code>i</code> 的 <strong>边积分</strong> 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 <strong>编号</strong> 总和。</p><p>返回 <strong>边积分</strong> 最高的节点。如果多个节点的 <strong>边积分</strong> 相同，返回编号 <strong>最小</strong> 的那个。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：edges = [1,0,0,0,0,7,7,5]<br>输出：7<br>解释：<br>- 节点 1、2、3 和<span class="hljs-number"> 4 </span>都有指向节点<span class="hljs-number"> 0 </span>的边，节点<span class="hljs-number"> 0 </span>的边积分等于<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 10 </span>。<br>- 节点<span class="hljs-number"> 0 </span>有一条指向节点<span class="hljs-number"> 1 </span>的边，节点<span class="hljs-number"> 1 </span>的边积分等于<span class="hljs-number"> 0 </span>。<br>- 节点<span class="hljs-number"> 7 </span>有一条指向节点<span class="hljs-number"> 5 </span>的边，节点<span class="hljs-number"> 5 </span>的边积分等于<span class="hljs-number"> 7 </span>。<br>- 节点<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 6 </span>都有指向节点<span class="hljs-number"> 7 </span>的边，节点<span class="hljs-number"> 7 </span>的边积分等于<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 11 </span>。<br>节点<span class="hljs-number"> 7 </span>的边积分最高，所以返回<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：edges = [2,0,0,2]<br>输出：0<br>解释：<br>- 节点<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>都有指向节点<span class="hljs-number"> 0 </span>的边，节点<span class="hljs-number"> 0 </span>的边积分等于<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>。<br>- 节点<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>都有指向节点<span class="hljs-number"> 2 </span>的边，节点<span class="hljs-number"> 2 </span>的边积分等于<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>节点<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>的边积分都是<span class="hljs-number"> 3 </span>。由于节点<span class="hljs-number"> 0 </span>的编号更小，返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == edges.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= edges[i] &lt; n</code></li><li><code>edges[i] != i</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>图中共有<code>n</code>个顶点，每个顶点只有一条有向边指向其他顶点，统计被指向的顶点数目<code>score[edge[i]]</code>，最大的<code>score</code>值即为所求顶点</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1> <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">edgeScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span>&gt; <span class="hljs-title">score</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            score[edges[i]] +=i;<br>        &#125;<br>        <span class="hljs-type">long</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> point = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(score[i] &gt; max)&#123;<br>                max = score[i];<br>                point = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> point;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数相加</title>
    <link href="/2024/09/24/addTwoNumbers/"/>
    <url>/2024/09/24/addTwoNumbers/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>​初始思路考虑将逆序存放在链表中的数转化为<code>int</code>型整数，二者相加求和后逐位存放到新链表中，但由于链表的长度不确定，最后求和的结果可能远远超出<code>int、long</code>的表示范围，更换<code>float、double</code>后会导致精度丢失问题，该题并不能用数学方法求解</p><p>​那么考虑逐位进行计算结果，对结果是否进位进行标识，如果数组长度相同，那么同时遍历即可，若二者长度不同，则遍历完短链表后单独将长链表剩余的节点插入至新链表后，上述都需考虑最终结果是否进位</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>精度丢失</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">double</span>  getNum(ListNode* l)&#123;<br>        <span class="hljs-keyword">if</span>(l-&gt;<span class="hljs-keyword">next</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> l-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>(l-&gt;val + getNum(l-&gt;<span class="hljs-keyword">next</span>) * <span class="hljs-number">10</span>);<br>    &#125;<br>    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;<br>        <span class="hljs-built_in">double</span>  <span class="hljs-keyword">sum</span> = getNum(l1)  + getNum(l2);<br>        cout&lt;&lt;<span class="hljs-keyword">sum</span>;<br>        ListNode* L = <span class="hljs-keyword">new</span> ListNode();<br>        ListNode* q = <span class="hljs-keyword">new</span> ListNode();<br>        q = L;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">sum</span> &gt;= <span class="hljs-number">10</span>)&#123;<br>            ListNode* p = <span class="hljs-keyword">new</span> ListNode(fmod(<span class="hljs-keyword">sum</span>,<span class="hljs-number">10</span>));<br><br>            <span class="hljs-keyword">sum</span> = <span class="hljs-keyword">sum</span> / <span class="hljs-number">10</span>;<br>            q-&gt;<span class="hljs-keyword">next</span> = p;<br>            q = q-&gt;<span class="hljs-keyword">next</span>;<br><br>        &#125;<br>        ListNode* p = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-keyword">sum</span>);<br>        p-&gt;<span class="hljs-keyword">next</span> = q-&gt;<span class="hljs-keyword">next</span>;<br>        q-&gt;<span class="hljs-keyword">next</span> = p;<br>        L = L-&gt;<span class="hljs-keyword">next</span>;   <br>        <span class="hljs-keyword">return</span> L;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确解</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">/**<br> * <span class="hljs-type">Definition</span> <span class="hljs-keyword">for</span> singly-linked <span class="hljs-built_in">list</span>.<br> * <span class="hljs-keyword">struct</span> <span class="hljs-type">ListNode</span> &#123;<br> *     <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br> *     <span class="hljs-type">ListNode</span> *next;<br> *     <span class="hljs-type">ListNode</span><span class="hljs-literal">()</span> : <span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>), next(nullptr) &#123;&#125;<br> *     <span class="hljs-type">ListNode</span>(<span class="hljs-built_in">int</span> x) : <span class="hljs-keyword">val</span>(x), next(nullptr) &#123;&#125;<br> *     <span class="hljs-type">ListNode</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-type">ListNode</span> *next) : <span class="hljs-keyword">val</span>(x), next(next) &#123;&#125;<br> * &#125;;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;<br>public:<br>    <span class="hljs-type">ListNode</span>* addTwoNumbers(<span class="hljs-type">ListNode</span>* l1, <span class="hljs-type">ListNode</span>* l2) &#123;<br>        <span class="hljs-type">ListNode</span>* <span class="hljs-type">L</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span><span class="hljs-literal">()</span>;<br>        <span class="hljs-type">ListNode</span>* q = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span><span class="hljs-literal">()</span>;<br>        q = <span class="hljs-type">L</span>;<br>        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != nullptr &amp;&amp; l2 != nullptr)&#123;<br>            <span class="hljs-built_in">int</span> num = l1-&gt;<span class="hljs-keyword">val</span> + l2-&gt;<span class="hljs-keyword">val</span> + carry; <br>            carry = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">10</span>)&#123;<br>                num = num - <span class="hljs-number">10</span>;<br>                carry = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">ListNode</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>(num);<br>            q-&gt;next = p;<br>            q = p;<br>            l1 = l1-&gt;next;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l1 != nullptr)&#123;<br>            <span class="hljs-built_in">int</span> num = l1-&gt;<span class="hljs-keyword">val</span> + carry;<br>            carry = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">10</span>)&#123;<br>                num -=<span class="hljs-number">10</span>;<br>                carry = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">ListNode</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>(num);<br>            q-&gt;next = p;<br>            q = p;<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2 != nullptr)&#123;<br>            <span class="hljs-built_in">int</span> num = l2-&gt;<span class="hljs-keyword">val</span> + carry;<br>            carry = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">10</span>)&#123;<br>                num -=<span class="hljs-number">10</span>;<br>                carry = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">ListNode</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>(num);<br>            q-&gt;next = p;<br>            q = p;<br>            l2 =l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">ListNode</span>* p =<span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>(carry);<br>             q-&gt;next = p;<br>             q = p;<br>        &#125;<br>        return <span class="hljs-type">L</span>-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳观光组合</title>
    <link href="/2024/09/23/maxScoreSightseeingPair/"/>
    <url>/2024/09/23/maxScoreSightseeingPair/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个正整数数组 <code>values</code>，其中 <code>values[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为 <code>values[i] + values[j] + i - j</code> ，也就是景点的评分之和 <strong>减去</strong> 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：values = <span class="hljs-selector-attr">[8,1,5,2,6]</span><br>输出：<span class="hljs-number">11</span><br>解释：<span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>, j = <span class="hljs-number">2</span>, values<span class="hljs-selector-attr">[i]</span> + values<span class="hljs-selector-attr">[j]</span> + <span class="hljs-selector-tag">i</span> - j = <span class="hljs-number">8</span> + <span class="hljs-number">5</span> + <span class="hljs-number">0</span> - <span class="hljs-number">2</span> = <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：values </span>=<span class="hljs-string"> [1,2]</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= values.length &lt;= 5 * 104</code></li><li><code>1 &lt;= values[i] &lt;= 1000</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>基本解法为建立for循环嵌套语句，得到最大的<code>score</code>，但时间复杂度为O(n^2)，在问题规模过大时会导致超时</p><p>考虑时间复杂度为O(n)的算法：</p><p>​初始思路，将<code>i</code>、<code>j</code>初始化为0和1，变量k遍历<code>values</code>数组，若出现新的符合条件的<code>score</code>，<code>i</code>、<code>j</code>其中一个变为k。该算法更像贪心算法，当较大的符合条件的点连续出现尾端时，显然无法实现</p><p>​将<code>values[i] + i</code>和<code>values[j] - j</code>看作两个整体变量，只需遍历一次数组找出二者的最大值即可，需注意满足<code>i&lt;j</code>的条件</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-keyword">int</span> maxScoreSightseeingPair(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-keyword">values</span>) &#123;<br>        <span class="hljs-keyword">int</span> mx = <span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = values.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            ans = max(ans, mx + <span class="hljs-keyword">values</span>[i] - i);<br>            mx = max(mx, <span class="hljs-keyword">values</span>[i]+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找到小镇的法官</title>
    <link href="/2024/09/22/findJudge/"/>
    <url>/2024/09/22/findJudge/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p><p>如果小镇法官真的存在，那么：</p><ol><li>小镇法官不会信任任何人。</li><li>每个人（除了小镇法官）都信任这位小镇法官。</li><li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li></ol><p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [ai, bi]</code> 表示编号为 <code>ai</code> 的人信任编号为 <code>bi</code> 的人。</p><p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, trust = <span class="hljs-string">[[1,2]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, trust = <span class="hljs-string">[[1,3],[2,3]]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, trust = <span class="hljs-string">[[1,3],[2,3],[3,1]]</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= trust.length &lt;= 104</code></li><li><code>trust[i].length == 2</code></li><li><code>trust</code> 中的所有<code>trust[i] = [ai, bi]</code> <strong>互不相同</strong></li><li><code>ai != bi</code></li><li><code>1 &lt;= ai, bi &lt;= n</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>图相关问题，法官人选出度为0入读为1，判定即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findJudge</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;<br>        <span class="hljs-type">int</span> judge = <span class="hljs-number">-1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; trust.<span class="hljs-built_in">size</span>();i++)&#123;<br>            ans[trust[i][<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>][trust[i][<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> count_1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                count_1 += ans[i][j];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count_1 == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> count_2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                    count_2 += ans[j][i];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(count_2 == n<span class="hljs-number">-1</span>)<br>                    <span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;<br>            &#125;       <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>图</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总行驶距离</title>
    <link href="/2024/09/21/distanceTraveled/"/>
    <url>/2024/09/21/distanceTraveled/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>卡车有两个油箱。给你两个整数，<code>mainTank</code> 表示主油箱中的燃料（以升为单位），<code>additionalTank</code> 表示副油箱中的燃料（以升为单位）。</p><p>该卡车每耗费 <code>1</code> 升燃料都可以行驶 <code>10</code> km。每当主油箱使用了 <code>5</code> 升燃料时，如果副油箱至少有 <code>1</code> 升燃料，则会将 <code>1</code> 升燃料从副油箱转移到主油箱。</p><p>返回卡车可以行驶的最大距离。</p><p>注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 <code>5</code> 升燃料时突然且立即发生。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mainTank = 5, additionalTank = 10<br>输出：60<br>解释：<br>在用掉<span class="hljs-number"> 5 </span>升燃料后，主油箱中燃料还剩下 (5 -<span class="hljs-number"> 5 </span>+ 1) =<span class="hljs-number"> 1 </span>升，行驶距离为 50km 。<br>在用掉剩下的<span class="hljs-number"> 1 </span>升燃料后，没有新的燃料注入到主油箱中，主油箱变为空。<br>总行驶距离为 60km 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：mainTank </span>=<span class="hljs-string"> 1, additionalTank = 2</span><br><span class="hljs-string">输出：10</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">在用掉 1 升燃料后，主油箱变为空。</span><br><span class="hljs-string">总行驶距离为 10km 。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= mainTank, additionalTank &lt;= 100</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>数学问题，只需考虑每五公里给主油箱中补充<code>1</code>单位的副油箱，计算距离即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> distanceTraveled(<span class="hljs-built_in">int</span> mainTank, <span class="hljs-built_in">int</span> additionalTank) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> distance = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(mainTank&gt;<span class="hljs-number">0</span>)&#123;<br>            distance++;<br>            <span class="hljs-keyword">count</span>++;<br>            mainTank--;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>==<span class="hljs-number">5</span> &amp;&amp; additionalTank!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span>=<span class="hljs-number">0</span>;<br>                additionalTank--;<br>                mainTank++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> distance*<span class="hljs-number">10</span>;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计特殊整数</title>
    <link href="/2024/09/21/countSpecialNumbers/"/>
    <url>/2024/09/21/countSpecialNumbers/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>如果一个正整数每一个数位都是 <strong>互不相同</strong> 的，我们称它是 <strong>特殊整数</strong> 。</p><p>给你一个 <strong>正</strong> 整数 <code>n</code> ，请你返回区间 <code>[1, n]</code> 之间特殊整数的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 20<br>输出：19<br>解释：1 到<span class="hljs-number"> 20 </span>之间所有整数除了<span class="hljs-number"> 11 </span>以外都是特殊整数。所以总共有<span class="hljs-number"> 19 </span>个特殊整数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br>解释：<span class="hljs-number">1</span> 到 <span class="hljs-number">5</span> 所有整数都是特殊整数。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 135<br>输出：110<br>解释：从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 135 </span>总共有<span class="hljs-number"> 110 </span>个整数是特殊整数。<br>不特殊的部分数字为：22 ，114 和<span class="hljs-number"> 131 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 109</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑动态规划，第<code>i</code>个正整数的特殊整数数目为<code>i-1</code>的数目加上自身是否为特殊整数，类似递归求解</p><p>只需判断整数<code>i</code>是否为特殊整数即可，时间复杂度太高</p><p>以<code>1100</code>为例，从<code>1100-1199</code>都不是特殊整数，因此可以考虑找到重复的部位，其后<code>99……9</code>个数都不是特殊整数，可降低一定的复杂度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> countSpecialNumbers(<span class="hljs-built_in">int</span> n) &#123;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; special(n,<span class="hljs-number">0</span>);<br>        special[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">int</span> num =  i + <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>;<br>                string s = std::to_string(num);<br>                <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(j &lt; s.length() &amp;&amp; <span class="hljs-built_in">count</span>==<span class="hljs-number">1</span>)&#123;<br>                    for(<span class="hljs-built_in">int</span> k = j+<span class="hljs-number">1</span>;k&lt;s.length();k++)&#123;<br>                        <span class="hljs-keyword">if</span>(s[j]==s[k])&#123;<br>                            <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br>                            <span class="hljs-keyword">target</span> =pow(<span class="hljs-number">10</span>,s.length()-k-<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>                            break;<br>                        &#125;<br>                    &#125;<br>                    j++;<br>                &#125;<br>                special[i] = special[i-<span class="hljs-number">1</span>] + <span class="hljs-built_in">count</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">target</span>--;<br>                special[i] = special[i-<span class="hljs-number">1</span>];<br>            &#125; <br>        &#125;<br>    <span class="hljs-keyword">return</span> special[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长的字母序连续子字符串的长度</title>
    <link href="/2024/09/19/longestContinuousSubstring/"/>
    <url>/2024/09/19/longestContinuousSubstring/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code> 的任意子字符串都是 <strong>字母序连续字符串</strong> 。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是一个字母序连续字符串，而 <code>&quot;acb&quot;</code> 和 <code>&quot;za&quot;</code> 不是。</li></ul><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> ，返回其 <strong>最长</strong> 的 字母序连续子字符串 的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abacaba&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：共有 <span class="hljs-number">4</span> 个不同的字母序连续子字符串 <span class="hljs-string">&quot;a&quot;</span>、<span class="hljs-string">&quot;b&quot;</span>、<span class="hljs-string">&quot;c&quot;</span> 和 <span class="hljs-string">&quot;ab&quot;</span> 。<br><span class="hljs-string">&quot;ab&quot;</span> 是最长的字母序连续子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<span class="hljs-string">&quot;abcde&quot;</span> 是最长的字母序连续子字符串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>通过<code>ASCII码</code>比较是否为连续字符串，记录连续的字符串数目<code>count</code></p><p>若不连续，则下次从第<code>i+count</code>处开始查找</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> longestContinuousSubstring(string s) &#123;<br>        <span class="hljs-built_in">int</span> n = s.length();<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>;<br>            for(<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>((s[i] + <span class="hljs-built_in">count</span>) == s[j])&#123;<br>                    <span class="hljs-built_in">count</span>++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> break;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> &gt; <span class="hljs-built_in">max</span>)<br>            <span class="hljs-built_in">max</span> = <span class="hljs-built_in">count</span>;<br>        i = i + <span class="hljs-built_in">count</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公交站间的距离</title>
    <link href="/2024/09/16/distanceBetweenBusStops/"/>
    <url>/2024/09/16/distanceBetweenBusStops/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>环形公交路线上有 <code>n</code> 个站，按次序从 <code>0</code> 到 <code>n - 1</code> 进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code> 表示编号为 <code>i</code> 的车站和编号为 <code>(i + 1) % n</code> 的车站之间的距离。</p><p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p><p>返回乘客从出发点 <code>start</code> 到目的地 <code>destination</code> 之间的最短距离。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：distance = [1,2,3,4], start = 0, destination = 1<br>输出：1<br>解释：公交站<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>之间的距离是<span class="hljs-number"> 1 </span>或 9，最小值是 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：distance = [1,2,3,4], start = 0, destination = 2<br>输出：3<br>解释：公交站<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>之间的距离是<span class="hljs-number"> 3 </span>或 7，最小值是 3。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：distance = [1,2,3,4], start = 0, destination = 3<br>输出：4<br>解释：公交站<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>之间的距离是<span class="hljs-number"> 6 </span>或 4，最小值是 4。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>distance.length == n</code></li><li><code>0 &lt;= start, destination &lt; n</code></li><li><code>0 &lt;= distance[i] &lt;= 10^4</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>距离计算有两个方向，可以视为一个循环数组，从两端分别计算距离取最小值</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-keyword">int</span> distanceBetweenBusStops(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; distance, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> destination) &#123;<br>        <span class="hljs-keyword">int</span> n = distance.size();<br>        <span class="hljs-keyword">int</span> dist_1=<span class="hljs-number">0</span>,dist_2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = start, j=destination;<br>        <span class="hljs-keyword">while</span>(i<span class="hljs-variable">%n</span> != destination)&#123;<br>            dist_1 += distance[i<span class="hljs-variable">%n</span>];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j<span class="hljs-variable">%n</span> != start)&#123;<br>            dist_2 += distance[j<span class="hljs-variable">%n</span>];<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span>(dist_1&lt;dist_2?dist_1:dist_2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>与车相交的点</title>
    <link href="/2024/09/15/numberOfPoints/"/>
    <url>/2024/09/15/numberOfPoints/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 表示汽车停放在数轴上的坐标。对于任意下标 <code>i</code>，<code>nums[i] = [starti, endi]</code> ，其中 <code>starti</code> 是第 <code>i</code> 辆车的起点，<code>endi</code> 是第 <code>i</code> 辆车的终点。</p><p>返回数轴上被车 <strong>任意部分</strong> 覆盖的整数点的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = <span class="hljs-string">[[3,6],[1,5],[4,7]]</span><br>输出：<span class="hljs-number">7</span><br>解释：从 <span class="hljs-number">1</span> 到 <span class="hljs-number">7</span> 的所有点都至少与一辆车相交，因此答案为 <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = <span class="hljs-string">[[1,3],[5,8]]</span><br>输出：<span class="hljs-number">7</span><br>解释：<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">5</span>、<span class="hljs-number">6</span>、<span class="hljs-number">7</span>、<span class="hljs-number">8</span> 共计 <span class="hljs-number">7</span> 个点满足至少与一辆车相交，因此答案为 <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>nums[i].length == 2</code></li><li><code>1 &lt;= starti &lt;= endi &lt;= 100</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>该题本质为求数轴上的所有区间，每个区间都有起点和终点</p><p>将二维数组按起点大小排序，第一项必定是整个总区间的起点，后续的区间仅可能有三种情况</p><p>一、包含在总区间内，此时相交的点数并没有增加</p><p>二、起点在总区间内而终点在总区间外，此时新增加的点为从原区间终点到现区间终点</p><p>三、起点在总区间外，此时新增加的点为该区间的长度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> count = nums[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        cout&lt;&lt;count;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i][<span class="hljs-number">0</span>] &lt;= nums[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])<br>                nums[i][<span class="hljs-number">0</span>] = nums[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<span class="hljs-number">+1</span>;<br>            <span class="hljs-keyword">if</span>(nums[i][<span class="hljs-number">1</span>] &lt;= nums[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])<br>            &#123;<br>                nums[i][<span class="hljs-number">1</span>] = nums[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            count += nums[i][<span class="hljs-number">1</span>] - nums[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>            cout&lt;&lt;count&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>每日一题</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2024/09/14/twoSum/"/>
    <url>/2024/09/14/twoSum/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>利用双指针建立双循环操作，遍历数组</p><p>若满足<code>nums[i] + nums[j] = target</code>，返回当前的<code>i</code>和<code>j</code></p><p>为降低时间复杂度，使用<code>C++STL</code>中的<code>unordered_map</code>，利用哈希表进行查找值，其内在实现为红黑树，查找结点的时间复杂度为O(1)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> &#123;i,j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>哈希表求解，时间复杂度O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap;<span class="hljs-comment">//unordered_map&lt;key,value&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">auto</span> it = umap.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span>(it != umap.<span class="hljs-built_in">end</span>())&#123;<br>                cout&lt;&lt;it-&gt;second&lt;&lt;endl;<br>                <span class="hljs-keyword">return</span> &#123;i,it-&gt;second&#125;;<br>            &#125;<br>            umap[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求出最多标记下标</title>
    <link href="/2024/09/12/maxNumOfMarkedIndices/"/>
    <url>/2024/09/12/maxNumOfMarkedIndices/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>一开始，所有下标都没有被标记。你可以执行以下操作任意次：</p><ul><li>选择两个 <strong>互不相同且未标记</strong> 的下标 <code>i</code> 和 <code>j</code> ，满足 <code>2 * nums[i] &lt;= nums[j]</code> ，标记下标 <code>i</code> 和 <code>j</code> 。</li></ul><p>请你执行上述操作任意次，返回 <code>nums</code> 中最多可以标记的下标数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,5,2,4]<br>输出：2<br>解释：第一次操作中，选择 i =<span class="hljs-number"> 2 </span>和 j =<span class="hljs-number"> 1 </span>，操作可以执行的原因是<span class="hljs-number"> 2 </span>* nums[2] &lt;= nums[1] ，标记下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 1 </span>。<br>没有其他更多可执行的操作，所以答案为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [9,2,5,4]<br>输出：4<br>解释：第一次操作中，选择 i =<span class="hljs-number"> 3 </span>和 j =<span class="hljs-number"> 0 </span>，操作可以执行的原因是<span class="hljs-number"> 2 </span>* nums[3] &lt;= nums[0] ，标记下标<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 0 </span>。<br>第二次操作中，选择 i =<span class="hljs-number"> 1 </span>和 j =<span class="hljs-number"> 2 </span>，操作可以执行的原因是<span class="hljs-number"> 2 </span>* nums[1] &lt;= nums[2] ，标记下标<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>。<br>没有其他更多可执行的操作，所以答案为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [7,6,8]</span><br><span class="hljs-string">输出：0</span><br><span class="hljs-string">解释：没有任何可以执行的操作，所以答案为 0 。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑满足标记的条件为<code>2 * nums[i] &lt;= nums[j]</code>，这题基本解为双指针</p><p>因为满足大小关系，先对数组进行排序后遍历求解，但不是最优解</p><p>由于数组长度为<code>size</code>，最大可能的标记数为<code>size/2</code>，此时每个<code>nums[i]</code>都能和<code>nums[size/2+i]</code>进行标记，贪心算法</p><p>若<code>标记数&lt;size/2</code>，也必将满足<code>2 * nums[i] &lt;= nums[j]</code>的<code>j &gt;size/2+i</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxNumOfMarkedIndices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> tag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;size; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = size/<span class="hljs-number">2</span>+i; j&lt;size;j++)&#123;<br>                <span class="hljs-keyword">if</span>(flag[i]==<span class="hljs-number">0</span> &amp;&amp; flag[j]==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span>*nums[i] &lt;= nums[j])&#123;<br>                    tag = tag + <span class="hljs-number">2</span>;<br>                    flag[i]=<span class="hljs-number">1</span>;<br>                    flag[j]=<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> tag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>二分查找</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CP</title>
    <link href="/2024/09/11/CP/"/>
    <url>/2024/09/11/CP/</url>
    
    <content type="html"><![CDATA[<h1 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="通信的基本概念"><a href="#通信的基本概念" class="headerlink" title="通信的基本概念"></a>通信的基本概念</h3><p>通信的目的： 传递消息中所包含的信息</p><p>模拟信号： 代表消息的信号参量取值连续</p><p>数字信号： 代表消息的信号参量取值为有限个</p><p>信号：是消息传输的载体</p><h3 id="通信系统模型"><a href="#通信系统模型" class="headerlink" title="通信系统模型"></a>通信系统模型</h3><p>一般模型 </p><p>信息源——发送设备——信道——接受设备——受信者</p><p>​      |</p><p>​噪声源</p><p>模拟通信系统模型</p><p>模拟信源——调制器——信道——解调器——信宿</p><p>​      |</p><p>​噪声源</p><p>数字通信系统模型</p><p>消息源-信源编码-加密-信道编码-数字调制-信道-数字解调-信道译码-解密-信源译码-受信者</p><p>​   |</p><p>​      噪声源</p><p>数字通信特点</p><p>优点</p><p>​抗干扰能力强、噪声不积累</p><p>​传输差错可控</p><p>​便于处理、变换、存储</p><p>​便于将来自不同信源的信号一起传输</p><p>​易于集成、易于加密、保密性好</p><p>缺点</p><p>​较大的传输带宽、同步要求高</p><h3 id="信息及度量"><a href="#信息及度量" class="headerlink" title="信息及度量"></a>信息及度量</h3><p>P(x)：消息发生的概率</p><p>I：消息中所含的信息量<br>$$<br>I&#x3D;log_a\frac{1}{P(x)}<br>$$</p><p>$$<br>I&#x3D;-log_aP(x)<br>$$</p><p>a&#x3D;2bit</p><p>a&#x3D;enat</p><p>a&#x3D;10Hartly</p><p>离散信源的平均信息量H(x)：单位(bit&#x2F;符号)<br>$$<br>H(x)&#x3D;-\sum_{i&#x3D;1}^nP(x_i)log_2P(x_i)<br>$$<br>连续信源的平均信息量H(x)：<br>$$<br>H(x)&#x3D;-\int_{-\infty}^{\infty}f(x)log_2f(x)dx<br>$$</p><h3 id="通信系统的性能指标"><a href="#通信系统的性能指标" class="headerlink" title="通信系统的性能指标"></a>通信系统的性能指标</h3><p>两大指标</p><p>​有效性：传递一定信息量时所占用的信道资源</p><p>​可靠性：指接收信息的准确程度</p><p>模拟通信系统</p><p>​有效性：传输频带宽度</p><p>​可靠性：接收端输出的信噪比</p><p>数字通信系统</p><p>​有效性：传输速率</p><p>​可靠性：误码率、误信率</p><p>有效性</p><p>码元传输速率 R<sub>B</sub> ：每秒传输码元的数目(Baud)<br>$$<br>R_B&#x3D;\frac{1}{T_B}<br>$$<br>T<sub>B</sub>是码元的持续时间</p><p>信息传输速率R<sub>b</sub>：每秒传输的平均信息量<br>$$<br>R_b&#x3D;R_Blog_2M<br>$$<br>可靠性：用差错概率来衡量<br>$$<br>误码率：P_e &#x3D; \frac{错误的码元数}{传输的总码元数}<br>$$</p><p>$$<br>误信率：P_b &#x3D; \frac{错误的比特数}{传输的总比特数}<br>$$</p><p>$$<br>在二进制中：P_b &#x3D; P_elog_2M<br>$$</p><h2 id="确知信号"><a href="#确知信号" class="headerlink" title="确知信号"></a>确知信号</h2><h3 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h3><p>可以用明确数学关系式描述的信号称为确知信号</p><p>不能用数学关系式描述的信号称为非确知信号</p><h4 id="确知信号-1"><a href="#确知信号-1" class="headerlink" title="确知信号"></a>确知信号</h4><h5 id="按周期性区分"><a href="#按周期性区分" class="headerlink" title="按周期性区分"></a>按周期性区分</h5><p>周期信号s(t)&#x3D;s(t+T)</p><p>非周期信号</p><h5 id="按能量区分"><a href="#按能量区分" class="headerlink" title="按能量区分"></a>按能量区分</h5><p>能量信号<br>$$<br>E&#x3D;\int^{\infty}_{-\infty}s^2(t)dt<br>$$<br>若P&#x3D;0且0&lt;E&lt;∞，称能量有限信号</p><p>功率信号<br>$$<br>P&#x3D;\displaystyle \lim_{T-∞}\frac{1}{T}\int^{\frac{T}{2}}_{-\frac{T}{2}}s^2(t)dt<br>$$<br>若E-&gt;∞且0&lt;P&lt;∞，称功率有限信号</p><p>能量信号特点：信号的振幅和持续时间均有限度，非周期性</p><p>功率信号特点：信号的持续时间无限</p><h3 id="确知信号的频域分析"><a href="#确知信号的频域分析" class="headerlink" title="确知信号的频域分析"></a>确知信号的频域分析</h3><h4 id="功率信号的频谱"><a href="#功率信号的频谱" class="headerlink" title="功率信号的频谱"></a>功率信号的频谱</h4><p>设s(t)是周期为T<sub>0</sub>的周期信号，展开指数形式的傅里叶级数为<br>$$<br>s(t)&#x3D;\displaystyle\sum^∞_{n&#x3D;-∞} C(n)e^{j2{\pi}nft&#x2F;T_0}<br>$$<br>将s(t)的傅里叶变换C(n)定义为频谱密度<br>$$<br>C(n)&#x3D;C(nf_0)&#x3D;\frac{1}{T_0}\int_{-{\frac{T_0}{2}}}^\frac{T_0}{2} s(t)e^{-j2\pi nf_0t}dt<br>$$<br><img src="C:\Users\Z_Jay\AppData\Roaming\Typora\typora-user-images\image-20240901173510164.png" alt="image-20240901173510164"></p><p>特点</p><p>​<img src="C:\Users\Z_Jay\AppData\Roaming\Typora\typora-user-images\image-20240901173441983.png" alt="image-20240901173441983"></p><h4 id="能量信号的频谱"><a href="#能量信号的频谱" class="headerlink" title="能量信号的频谱"></a>能量信号的频谱</h4><p>设s(t)是一个非周期信号，则它的傅里叶变换</p><p>正变换：<br>$$<br>S(f)&#x3D;\int_{-\infty}^{\infty}s(t)e^{-j2\pi ft}dt<br>$$<br>负变换：<br>$$<br>s(t)&#x3D;\int_{-\infty}^{\infty}S(f)e^{j2\pi ft}dt<br>$$<br>规律：正变换为负，负变换为正</p><h4 id="傅里叶变换的基本性质"><a href="#傅里叶变换的基本性质" class="headerlink" title="傅里叶变换的基本性质"></a>傅里叶变换的基本性质</h4><p><img src="C:\Users\Z_Jay\AppData\Roaming\Typora\typora-user-images\image-20240901174116215.png" alt="image-20240901174116215"></p><h4 id="常见信号及其性质"><a href="#常见信号及其性质" class="headerlink" title="常见信号及其性质"></a>常见信号及其性质</h4><h3 id="确知信号的时域分析"><a href="#确知信号的时域分析" class="headerlink" title="确知信号的时域分析"></a>确知信号的时域分析</h3>]]></content>
    
    
    
    <tags>
      
      <tag>preview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建站小记</title>
    <link href="/2024/09/10/test/"/>
    <url>/2024/09/10/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/10/hello-world/"/>
    <url>/2024/09/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
